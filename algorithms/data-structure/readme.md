
## Set 集合
- 集合是一种无序且不允许值重复的顺序数据结构。
- 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合；
- 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合；
- 差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合；
- 子集：验证一个给定集合是否是另一个集合的子集；

## Dictionary & HashMap 字典和散列表
- 字典以【键，值】的形式来存储元素，字典也称作映射、符号表或关联数组。
- 当散列因子（元素个数除以表长度）大于 0.7时，一般需要调整散列表的长度。
- 一个良好的散列函数，SHA函数，可用作散列表的哈希函数。

- 解决散列冲突
  - 分离链接
    - 为散列表每一个位置创建一个链表并将元素存储在里面；
  - 线性探查
    - 元素任然存储在散列表中，但如果计算出的位置被占据则往后找空位；
  - 双散列法
    - 遇到冲突，使用另一个散列函数进行散列计算出新位置；
  - 再散列法
    - 当表快满或遇到某个预设的临界值时，创建一个新的表，然后把旧的表散列到新的表上；

## 树 🌲
- 树是一种非线性数据结构，是一种分层数据的抽象模型；
  - 一个树结构包含一系列存在父子关系的节点；
  - 每个节点都有一个父节点（除根节点外）以及零个或多个子节点；
  - 节点有一个属性是深度，节点的深度取决于它的祖先节点的数量；
- 遍历方法
  - 中序遍历
    - 先访问左边节点，然后访问自身，最后访问右边节点；
    - 对树进行排序操作；（从小到大）
  - 先序遍历
    - 先访问自身，然后左边节点，最后右边节点；
    - 先序遍历的一种应用是打印一个结构化的文档；
  - 后序遍历
    - 先访问左边节点，然后访问右边节点，最后访问自身；
    - 后序遍历的一种应用是计算一个子目录及其子目录中所有文件所占空间的大小；
- 移除节点
  - 让当前的节点指向经过移除操作后的新节点；

## 图
- 加权图
  - 要计算加权图中的最短路径，可使用狄克斯特拉算法。
    - 狄克斯特拉算法只适用于有向无环图（directed acyclic graph，DAG）。
    - 狄克斯特拉算法只适用于正权边节点。（权重的表示为正数）
  - 可使用贝尔曼福德算法（ Bellman-Ford algorithm ）。
    - 贝尔曼福德算法适用于负权边节点。（权重的表示为负数）
- 非加权图
  - 要计算非加权图中的最短路径，可使用广度优先算法。

## 性能比较
##### Tips：这里的操作是分开的，如果需要查找后再插入或删除，性能需要重新评估。

###### 数组
- 查找: 平均 O(1)，最坏 O(1)
- 插入: 平均 O(n)，最坏 O(n)
- 删除: 平均 O(n)，最坏 O(n)

###### 链表
- 查找: 平均 O(n)，最坏 O(n)
- 插入: 平均 O(1)，最坏 O(1)
- 删除: 平均 O(1)，最坏 O(1)

###### 散列表
- 查找: 平均 O(1)，最坏 O(n)
- 插入: 平均 O(1)，最坏 O(n)
- 删除: 平均 O(1)，最坏 O(n)


## 概念术语
- 冲突 collision
- 改变大小 resizing
- 先进先出 First In First Out，FIFO
- 后进先出 Last In Last Out，LIFO
- 广度优先搜索 breadth-first search，BFS
  - 用于解决两个节点之间是否存在路径？
  - 用于解决最短路径问题；
    - 编写国际跳棋 AI，计算最少走多少步就可获胜；
    - 编写拼写检查器；
    - 人际关系网络，最近的人脉；
- 最短路径问题 shorterst-path problem
- 节点 node
  - 节点是与对象对应的顶点。
- 边 edge
  - 边是对象之间的连接。
  - 图的边有时会有权重，表示节点之间的每个连接的强度（或一些其他属性）。
- 有向图 directed graph
  - 一条边<x,y>与<y,x>表示的结果不相同，用尖括号表示。<x,y>表示从顶点x发向顶点y的边，x为始点，y为终点。
- 无向图 undirected graph
  - 直接相连的节点。
  - 一条边（x,y）与（y,x）表示的结果相同，用圆括号表示。
- 加权图 weighted graph
- 非加权图 unweighted graph
