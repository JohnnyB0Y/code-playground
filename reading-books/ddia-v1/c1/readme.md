# 可靠、可扩展与可维护的应用系统

###### 数据密集型应用通常也是基于标准模块构建而成，每个模块负责单一的常用功能：
- 数据库：用以存储数据，这样之后应用可以再次访问。
- 高速缓存：缓存那些复杂或操作代价昂贵的结果，以加快下一次访问。
- 索引：用户可以按关键字搜索数据并支持各种过滤。
- 流式处理：持续发送消息至另一个进程，处理采用异步方式。
- 批处理：定期处理大量的累积数据。

### 可靠性 - Reliability
- 当出现意外情况如硬件、软件故障、人为失误等，系统应该可以继续正常运转：虽然性能可能有所降低，但确保功能正确。
- 注意，故障与失效（failure）不完全一致。故障通常被定义为组件偏离其正常规格，而失效意味着系统作为一个整体停止，无法向用户提供所需服务。
- 通常，我们设计容错机制来避免从故障引发的系统失效。

###### 硬件故障 ❌
- 包括：硬盘崩溃、内存故障、电网停电、甚至有人拔掉网线。
- 有研究证明硬盘的平均无故障时间（MTTF）约为 10~50年。因此，在一个包括1万个磁盘的存储集群中，我们应该预期平均每天有一个磁盘发生故障。
- 通常，我们会为硬件添加冗余来减少系统故障率。如对磁盘配置 RAID、服务器配备双电源、甚至热拔插CPU、数据中心添加备用电源和发电机等。
- 通过软件容错也是解决多机失效的好方式。

###### 软件错误 ❌
- 包括：操作系统内核的bug、依赖的服务变慢或无响应、一个组件的小故障触发另一个组件故障，进而引发更多的系统问题。
- 软件系统问题有时没有快速解决办法，而只能仔细考虑很多细节。包括，检测依赖、监控分析等。

###### 人为失误 ❌
- 包括：配置错误、误删数据等。
- 如果我们假定人是不可靠的，那么该如何保证系统的可靠性呢？？？
- 以最小出错的方式来设计系统。例如精心设计抽象层、API以及管理界面。
  - 注意，如果限制过多会适得其反，关键在于平衡。
- 想办法分离最容易出错的地方、容易引发故障的接口。
  - 提供一个预发布环境，使人们可以放心导入真实数据，测试体验。
- 充分的测试。
  - 从各单元测试到全系统集成测试以及手动测试，覆盖正常操作中很少出现的边界条件等尤为重要。
- 当出现人为失误时，提供快速恢复的机制以尽量减少故障影响。
  - 例如，快速回滚配置改动，滚动发布新代码，并提供校验数据的工具（防止旧的计算方式不正确）。
- 设置详细而清晰的监控子系统，包括性能指标和错误率。
- 推行管理流程并加以培训。

### 可扩展性 - Scalability
- 随着规模的增长，例如数据量、流量或复杂性，系统应以合理的方式来匹配这种增长。
- 如果系统以某种方式增长，我们应对增长的措施有哪些？我们应该如何添加计算资源来处理额外的负载？

###### 描述负载
- 它可能是 Web服务器的每秒请求处理次数，数据库中的写入比例，聊天室的同时活动用户数量，缓存命中率等。
- 有时平均值很重要，有时系统瓶颈来自于少数峰值。

###### 描述性能
- 吞吐量，每秒可处理的记录条数，或者在某指定数据集上运行作业所需的总时间；
- 而在线系统通常更看重服务的响应时间，即客户端从发送请求到接收响应之间的间隔。
- 一些随机延迟抖动，包括上下文切换和进程调度、网络数据丢包和TCP重传、垃圾回收暂停、缺页中断和磁盘I/O，甚至服务器机架的机械抖动。
- 最好使用百分位来描述响应时间。例如中位数响应时间为200ms，也称为50百分位数，有时缩写成 p50，表示有一半的请求响应不到200ms，而另一半需要更长时间。
- 采用较高的响应时间百分位数很重要，因为它们直接影响用户的总体体验。
- 百分位数通常用于描述、定义服务质量目标（Service Level Objectives，SLO）和服务质量协议（Service Level Agreements，SLA）。
- 例如，一根SLA合约通常会声明，响应时间中位数小于200ms，99%请求的响应时间小于 1s，且要求99.9%的时间都要达到上述服务指标。
- 使用客户端来测量响应时间，这样最反应用户体验。服务端设置一个10min的滑动窗口，监控其中响应时间，滚动计算窗口中的中位数和各种百分位数，然后绘制性能图表。

### 可维护性 - Maintainability
- 随着时间的推移，许多新的人员参与到系统开发和运维，以维护现有功能或适配新场景等，系统都应高效运转。

###### 可运维性：运维更轻松
- 制定流程来规范操作行为，并保持生产环境稳定。
- ...
- 支持自动化，与标准工具集成。
- ...

###### 简单性：简化复杂度
- 消除意外复杂性最好手段之一是抽象。
- 一个好的设计抽象可以隐藏大量的实现细节，并对外提供干净、易懂的接口。

###### 可演化性：易于改变
- 我们的目标是可以轻松地修改数据系统，使其适应不断变化的需求，这和简单性与抽象性密切相关。


